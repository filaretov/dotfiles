#+title: Emacs Configuration
#+author: Hristo Filaretov
* Preamble
Most of this is based on Harry Schwartz's [[https://github.com/hrs/dotfiles/blob/master/emacs/.hgf-emacs-path/configuration.org][configuration]] and is also inspired by
many his talks and blog posts.

I assume that =use-package= and =general= are always available and sprinkle their
incantations generously throughout the configuration.

I tried using =straight=, but I wound up having some trouble with =org-mode=, and
although I think it was documented somewhere, I'm more than happy with the
regular =package=.

* =use-package=
I use =use-package= for packaging my used packages.

#+begin_src emacs-lisp
(use-package use-package
  :config
  (setq use-package-always-ensure t))
#+end_src

* =general=
I use =general= for my keybindings. It's generally quite good. The keybindings
themselves will be found throughout this file.

#+begin_src emacs-lisp
(use-package general
  :config
  (general-evil-setup)

  (global-set-key [remap dabbrev-expand] 'hippie-expand)

  (general-create-definer hgf-leader-def
    :keymaps '(normal visual)
    :prefix "SPC")


  (general-create-definer hgf-c-def
    :prefix "C-c"))
#+end_src

* Compile
I mostly use compilation with Latex, surprisingly enough.

#+begin_src emacs-lisp
(defun hgf--close-compilation-if-successful (buf str)
  "Close the compilation window if it is successful."
  (if (null (string-match ".*exited abnormally.*" str))
      ;;no errors, make the compilation window go away in a few seconds
      (progn
	(run-at-time
	 "1 sec" nil 'kill-buffer
	 (get-buffer-create "*compilation*"))
	(message "No Compilation Errors!"))))

(use-package compile
  :ensure nil
  :config
  (general-nmap "C-x c" 'recompile)
  (add-hook 'compilation-finish-functions
  'hgf--close-compilation-if-successful))
#+end_src

* Files

#+begin_src emacs-lisp
(use-package files
  :ensure nil
  :config (general-def "C-s" 'save-buffer))
#+end_src

* Imenu

#+begin_src emacs-lisp
(use-package imenu
  :ensure nil
  :config
  (general-nmap "M-i" 'imenu))
#+end_src

* Flycheck

#+begin_src emacs-lisp
(use-package flycheck)
#+end_src

* Common paths
Building common paths.

#+begin_src emacs-lisp
(defun hgf-emacs-path (filename)
  "Return the file path of FILENAME relative to the Emacs directory."
  (format "%s%s" user-emacs-directory filename))

(defun hgf-journal-path (filename)
  "Return the file path of FILENAME relative to the Journal directory."
  (format "%s%s" "~/cloud/journal/" filename))
#+end_src

* Macros
I only have a single macro defined. And it probably exists in the standard
library, or a commonly used package. And yet here we are.

#+begin_src emacs-lisp
(defmacro ~> (init &rest lst)
  "Pipe INIT through LST.

Evaluate transformation pipeline LST. Either append argument at
the end or replace all :arg occurences (starting with INIT).

Example:
(pipe (number-sequence 1 10)
      (-filter 'evenp)
      (mapcar '1+))
=> (3 5 7 9 11)

(pipe (number-sequence 1 10)
    (-filter 'evenp)
    (mapcar '1+)
    (-filter (lambda (x) (= 0 (mod x 3))))
    (mapcar '1+)
    (-filter (lambda (x) (= 0 (mod x 5)))))
=> (10)

(pipe 1
      (1+)
      (1+)
      ((lambda (x y) (+ y x)) :arg 100))
=> 103"
  (reduce (lambda (acc el)
	    (if (member :arg el)
		(-replace :arg acc el)
	      (append el `(,acc))))
	  lst
	  :initial-value init))
#+end_src

* Add =resources= to =load-path=
#+begin_src emacs-lisp
(add-to-list 'load-path (hgf-emacs-path "resources"))
#+end_src

* Personal information
Just letting Emacs know who I am.

#+begin_src emacs-lisp
(setq user-full-name "Hristo Filaretov"
      user-mail-address "h.filaretov@campus.tu-berlin.de")
#+end_src

* Faces
Depending on the operating system, there are a few options.

#+begin_src emacs-lisp
(defun hgf--set-font ()
  "Set a font depending on the OS."
  (cond ((eq system-type 'windows-nt)
	 (set-face-attribute 'default nil
			     :family "Consolas"
			     :height 110))
	((eq system-type 'darwin)
	 (set-face-attribute 'default nil
			     :family "Source Code Pro"
			     :height 120
			     :weight 'semi-bold))
	(t ;; t for true operating system
	 (progn
	   (set-face-attribute 'default nil
			       :family "Iosevka"
			       :height 130)
	   (set-face-attribute 'fixed-pitch nil
			       :family "Iosevka"
			       :height 130)
	   (set-face-attribute 'variable-pitch nil
			       :family "Source Serif Pro"
			       :height 130)))))

(defun text-scale-reset ()
  "Reset the height of the default face."
  (interactive)
  (text-scale-set 0))

(use-package faces
  :ensure nil
  :config
  (hgf--set-font)
  (general-def 'normal
    "C-+" 'text-scale-increase
    "C--" 'text-scale-decrease
    "C-=" 'text-scale-reset))
#+end_src

* Face modifications
Some things aren't meant to be. Like variable sized fonts in my org files.

#+begin_src emacs-lisp
(defun hgf-org-mode-hook ()
  "Disable header variable font size."
  (progn
    (dolist (face '(org-level-1
		    org-level-2
		    org-level-3
		    org-level-4
		    org-level-5
		    org-document-title))
      (set-face-attribute face nil :weight 'normal :height 1.0)))
  (set-face-attribute 'org-block nil :foreground nil))

(add-hook 'org-mode-hook 'hgf-org-mode-hook)

(defun hgf-outline-mode-hook ()
  "Disable header variable font size."
  (progn
    (dolist (face '(outline-1
		    outline-2
		    outline-3
		    outline-4
		    outline-5
		    outline-6
		    outline-7
		    outline-8))
      (set-face-attribute face nil :weight 'semi-bold :height 1.0))))
#+end_src

* Modeline

#+begin_src emacs-lisp
(setq-default
 mode-line-format
 '(
   ""
   ;; Buffer name
   "%b"
   "  "
   ;; Modified cookie
   mode-line-modified
   "  "
   ;; Major mode
   "%m"
   "  "
   ;; VC Branch
   (:eval (when-let (vc vc-mode)
	    (propertize (substring vc 5)
			'face 'fixed-pitch)))
   pyvenv-mode-line-indicator))
#+end_src


* Evil
Vimmy keys and feel, for us vimfolk.

#+begin_src emacs-lisp
(use-package evil
  :init
  (setq evil-want-integration t
	evil-want-keybinding nil
	evil-want-abbrev-expand-on-insert-exit nil)
  :config
  (evil-mode 1)
  (setq evil-emacs-state-cursor 'bar
	evil-search-module 'evil-search
	evil-ex-search-case 'smart)
  (general-nmap
    "j" 'evil-next-visual-line
    "k" 'evil-previous-visual-line
    "L" 'evil-end-of-line
    "H" 'evil-first-non-blank-of-visual-line
    "?" 'swiper
    "C-u" 'evil-scroll-up
    "C-w 1" 'delete-other-windows
    "C-w x" 'kill-this-buffer
    "C-w C-h" 'evil-window-left
    "C-w C-j" 'evil-window-down
    "C-w C-k" 'evil-window-up
    "C-w C-l" 'evil-window-right)
  (general-vmap
    "L" 'evil-end-of-line
    "H" 'evil-first-non-blank-of-visual-line)
  (general-imap
    "C-e" 'end-of-line
    "C-a" 'beginning-of-line
    "C-k" 'kill-line
    "C-d" 'delete-char
    "C-y" 'yank))
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
(use-package evil-magit)
(use-package evil-numbers)
(use-package evil-surround
  :config
  (global-evil-surround-mode 1))
(use-package evil-commentary
  :config
  (evil-commentary-mode 1)
  (general-nmap evil-commentary-mode-map
    "M-;" 'evil-commentary-line))
(use-package evil-exchange
  :config
  (evil-exchange-cx-install))
(use-package evil-org
  :after org
  :config
  (add-hook 'org-mode-hook 'evil-org-mode)
  (add-hook 'evil-org-mode-hook
	    (lambda () (evil-org-set-key-theme)))
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))
#+end_src

** C-i != TAB âˆ§ C-m != RET
I mean, they used to be, but we aren't limited to real terminals anymore, are
we?

#+begin_src emacs-lisp
(general-def input-decode-map [?\C-i] [C-i])
(general-def input-decode-map [?\C-m] [C-m])

(general-def 'normal "<C-i>" 'evil-jump-forward)
(general-unbind evil-motion-state-map "TAB")
#+end_src

* LSP & Completion

#+begin_src emacs-lisp
(use-package company
  :config (global-company-mode 1))
#+end_src

#+begin_src emacs-lisp
(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :init (setq lsp-keymap-prefix "C-c l")
  :config
  (setq gc-cons-threshold 200000000
	read-process-output-max (* 1024 1024 10)
	lsp-completion-provider :capf)
  (lsp-enable-which-key-integration t)

  (general-imap lsp-mode-map "C-x C-o" 'completion-at-point))

(use-package lsp-ui
  :commands lsp-ui-mode)

(use-package lsp-ivy
  :commands lsp-ivy-workspace-symbol)

(use-package company-lsp
  :config
  (add-to-list 'company-lsp-filter-candidates '(digestif . nil)))

(setq lsp-tex-server 'digestif)
(setq lsp-clients-digestif-executable "/home/hgf/.luarocks/bin/digestif")
(setq lsp-clients-texlab-executable "/home/hgf/.local/bin/texlab")

#+end_src

* Wrangle some defaults
#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :config
  (global-auto-revert-mode 1)
  (show-paren-mode 1)
  (scroll-bar-mode 0)
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (setq tab-bar-new-button-show nil
	tab-bar-close-button-show nil)
  (blink-cursor-mode 0)
  (fringe-mode '(nil . nil))
  (setq vc-follow-symlinks t
	sentence-end-double-space nil
	require-final-newline t
	confirm-kill-emacs 'y-or-n-p
	ring-bell-function 'ignore
	mode-line-default-help-echo nil
	show-paren-delay 0.0
	mouse-yank-at-point t
	default-input-method "TeX")
  (fset 'yes-or-no-p 'y-or-n-p)
  (add-hook 'after-save-hook
	    'executable-make-buffer-file-executable-if-script-p)

  (setq-default 
		cursor-type 'bar))
#+end_src

** Startup
#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq inhibit-startup-screen t
	inhibit-startup-message t
	initial-scratch-message nil
	initial-major-mode 'org-mode))
#+end_src

** Backups
#+begin_src emacs-lisp
(setq backup-inhibited t
      auto-save-default nil
      make-backup-files nil)
#+end_src

** Scrolling
#+begin_src emacs-lisp
(setq scroll-margin 0
      scroll-step 1
      scroll-conservatively 10000
      scroll-preserve-screen-position 1)
#+end_src

* Interactive goodies
Great guy, that Harry Schwartz. Most of these functions are directly copied from
his dotfiles.

** Open file as =sudo=

#+begin_src emacs-lisp
(defun hgf-find-file-as-sudo ()
  (interactive)
  (let ((file-name (buffer-file-name)))
    (when file-name
      (find-alternate-file (concat "/sudo::" file-name)))))
#+end_src

** Generate random scratch buffer

#+begin_src emacs-lisp
(defun hgf-generate-scratch-buffer ()
  "Create and switch to a temporary scratch buffer with a random
       name."
  (interactive)
  (switch-to-buffer (make-temp-name "scratch-")))
#+end_src

* Org
Org is amazing and I use it all the time. And once again, a large majority of
this section is inspired by Harry Schwartz.

#+begin_src emacs-lisp
(use-package org
  :config
  (general-nmap org-mode-map
    "g t" 'org-todo))
#+end_src

** GTD
All about them tasks.

#+begin_src emacs-lisp
(defun org-capture-inbox ()
  (interactive)
  (condition-case nil
      (call-interactively 'org-store-link)
    (error nil))
  (org-capture nil "i"))
(general-add-advice 'org-capture-inbox :after '(lambda () (evil-append 0)))
(setq org-refile-use-outline-path 'file
      org-clock-into-drawer nil
      org-log-done 'time)
(setq org-refile-targets `((,(hgf-journal-path "projects.org") :maxlevel . 2)
			   (,(hgf-journal-path "someday.org") :level . 1)
			   (,(hgf-journal-path "tickler.org") :level . 1)
			   (,(hgf-journal-path "inbox.org") :level . 0)
			   (,(hgf-journal-path "fraunhofer.org") :maxlevel . 3)))
(setq org-agenda-files
      '(
	"~/cloud/journal/projects.org"
	"~/cloud/journal/inbox.org"
	"~/cloud/journal/notes.org"
	"~/cloud/journal/fraunhofer.org"
	))
(setq org-archive-location "~/cloud/journal/archive.org::* %s")
(setq org-capture-templates
      '(("n" "Note" entry (file "~/cloud/journal/notes.org")
	 "*  %?\n")
	("i" "Inbox" entry (file "~/cloud/journal/inbox.org")
	 "* TODO %?\n")))
(hgf-leader-def
  "oc" 'org-capture
  "oa" 'org-agenda
  "oi" 'org-capture-inbox)
#+end_src

Alright, this function isn't exactly the cleanest possible thing in the world,
but it's useful enough for me (for now).

#+begin_src emacs-lisp
(defun org-generate-report ()
  (interactive)
  (let ((header "|Task|Duration|"))
    (insert (s-join "\n" (nconc `(,header) (org-element-map (org-element-parse-buffer) 'clock
					     (lambda (clock)
					       (let ((task (org-element-property :title (org-element-property :parent (org-element-property :parent clock))))
						     (val  (org-element-property :duration clock)))
						 (format "| %s | %s |" (car task) val)))))))))
(general-nmap "C-c C-x C-r" 'org-generate-report)
#+end_src

#+begin_src emacs-lisp
(general-add-advice 'org-clock-in :after 'hgf-activate-current-task)
#+end_src


** Babel

#+begin_src emacs-lisp
(add-to-list 'org-structure-template-alist
	     '("el" . "src emacs-lisp"))
(setq org-src-fontify-natively t
      org-src-preserve-indentation nil
      org-src-tab-acts-natively t
      org-edit-src-content-indentation 0
      org-src-window-setup 'current-window)
#+end_src

Ledger entries too, please

#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((dot . t)
   (emacs-lisp . t)
   (gnuplot . t)
   (haskell . nil)
   (latex . t)
   (ledger . t)
   (octave . t)
   (python . t)
   (ruby . t)))
#+end_src

** Cosmetics
I prefer my org-files non-indented. I also like to see the leading stars
(otherwise there's a weird gap when things aren't indented.

#+begin_src emacs-lisp
(setq org-adapt-indentation nil
      org-hide-leading-stars t
      org-cycle-separator-lines 0
      org-hide-emphasis-markers t
      org-fontify-done-headline nil)
#+end_src

I also prefer hiding the begin and end line of source blocks.

#+begin_src emacs-lisp
(add-hook
 'org-mode-hook
 (lambda ()
   "Beautify Org Symbols"
   (push '("#+begin_src" . "Î»") prettify-symbols-alist)
   (push '("#+end_src" . "~") prettify-symbols-alist)
   (prettify-symbols-mode)))
#+end_src

** Editing
I often start new headings in the middle of editing a paragraph and I've never
wanted to carry over the text after the point.

#+begin_src emacs-lisp
(setq org-M-RET-may-split-line nil
      org-outline-path-complete-in-steps nil)
#+end_src

Quickly adding a link with the title from said link. Nifty.

#+begin_src emacs-lisp
(use-package org-cliplink
  :config
  (general-def org-mode-map "C-x C-l" 'org-cliplink))
#+end_src

** References and citations

#+begin_src emacs-lisp
(setq reftex-default-bibliography '("~/cloud/library.bib"))
(setq bibtex-completion-bibliography
      '("~/cloud/library.bib"))
#+end_src

** Ox and Latex
I use org to write many of my latex files, including longer documents.

#+begin_src emacs-lisp
(with-eval-after-load 'ox-latex
  (add-to-list 'org-latex-classes
	       '("book"
		 "\\documentclass{book}\n[NO-DEFAULT-PACKAGES]\n[EXTRA]\n"
		 ("\\chapter{%s}" . "\\chapter*{%s}")
		 ("\\section{%s}" . "\\section*{%s}")
		 ("\\subsection{%s}" . "\\subsection*{%s}")
		 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
  (add-to-list 'org-latex-classes
	       '("ieee"
		 "\\documentclass{IEEEtran}\n[NO-DEFAULT-PACKAGES]\n[EXTRA]\n"
		 ("\\section{%s}" . "")
		 ("\\subsection{%s}" . "")
		 ("\\subsubsection{%s}" . "")))
  (add-to-list 'org-latex-classes
	       '("blank"
		 ""
		 ("\\section{%s}" . "")
		 ("\\subsection{%s}" . "")
		 ("\\subsubsection{%s}" . ""))))
(use-package ox-extra
  :ensure org-plus-contrib
  :commands ox-extras-activate
  :config
  (ox-extras-activate '(ignore-headlines)))
#+end_src

* Major modes

** Vterm
Vterm is the nicest terminal emulator for Emacs I've found so far. But it needs
module support, which requires building emacs with =--with-modules=.

#+begin_src emacs-lisp
(use-package vterm
  :config
  (setq vterm-shell "/usr/bin/fish"
	vterm-kill-buffer-on-exit t
	vterm-copy-exclude-prompt t)
  (general-nmap "<f4>" 'vterm))
#+end_src

#+begin_src emacs-lisp
(defun hgf-named-term (term-name)
  "Generate a terminal with buffer name TERM-NAME."
  (interactive "sTerminal purpose: ")
  (vterm (concat "term-" term-name)))

(hgf-leader-def "r t" 'hgf-named-term)
#+end_src

** Python
#+begin_src emacs-lisp
(use-package lsp-pyright
  :hook (python-mode . (lambda ()
			 (require 'lsp-pyright)
			 (lsp)))
  :config
  (setq flycheck-python-flake8-executable "flake8"))
(use-package blacken)
(use-package python-docstring)
(use-package pytest)
(use-package pyvenv
  :config
  (setenv "WORKON_HOME" "~/.cache/pypoetry/virtualenvs")
  (setq pyvenv-mode-line-indicator
	'(pyvenv-virtual-env-name ("[venv:" pyvenv-virtual-env-name "] "))))
#+end_src

Emacs IPython Notebooks

#+begin_src emacs-lisp
(use-package ein)
#+end_src

** Markdown
I use markdown for all kinds of stuff, mostly readmes, but also a variety of
documents in conjunction with =pandoc=.

#+begin_src emacs-lisp
(use-package markdown-mode
  :mode (("README\\.md\\'" . markdown-mode)
	 ("\\.md\\'" . markdown-mode)
	 ("\\.markdown\\'" . markdown-mode)))
#+end_src

** Ledger
Trackin' them finances.

#+begin_src emacs-lisp
(use-package ledger-mode
  :config
  (add-to-list 'ledger-reports '("diet" "%(binary) -f %(ledger-file) reg --value Assets --budget --daily"))
  (add-to-list 'ledger-reports '("work" "%(binary) -f %(ledger-file) bal --add-budget")))
#+end_src

** TeX
#+begin_src emacs-lisp
(use-package tex
:config
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq TeX-master nil)
(setq TeX-PDF-mode t))

(use-package auctex-latexmk
:config
(auctex-latexmk-setup)
(setq auctex-latexmk-inherit-TeX-PDF-mode t))

(defun hgf-bibtex-hook ()
"My bibtex hook."
(progn
(setq comment-start "%")))

(add-hook 'bibtex-mode-hook 'hgf-bibtex-hook)

(setq-default TeX-auto-save t
TeX-parse-self t
TeX-PDF-mode t
TeX-auto-local (hgf-emacs-path "auctex-auto"))
(setq bibtex-dialect 'biblatex)
#+end_src emacs-lisp

** Dired

#+begin_src emacs-lisp
(general-nmap "-" 'dired)
#+end_src

** Elixir

#+begin_src emacs-lisp
(use-package elixir-mode)
(use-package alchemist)
#+end_src

** Lua

#+begin_src emacs-lisp
(use-package lua-mode)
#+end_src

** RISCV

#+begin_src emacs-lisp
(use-package riscv-mode)
#+end_src

** Rust

#+begin_src emacs-lisp
(use-package rust-mode
  :config
  (setq lsp-rust-server 'rust-analyzer))
#+end_src

* Minor modes

** Which key
For exploring new keys and remembering the lesser used ones.

#+begin_src emacs-lisp
(use-package which-key
  :config
  (which-key-mode))
#+end_src

** Visual Fill Column

#+begin_src emacs-lisp
(use-package visual-fill-column
  :config
  (setq-default visual-fill-column-width 90))
#+end_src

** Outshine
#+begin_src emacs-lisp
(use-package outshine
  :config
  (setq outshine-startup-folded-p t)
  (add-hook 'conf-mode-hook #'outshine-mode 1)
  (add-hook 'prog-mode-hook #'outshine-mode 1)
  (add-hook 'bibtex-mode-hook #'outshine-mode 1)
  (add-hook 'LaTeX-mode-hook #'outshine-mode 1))
#+end_src

** Engine-mode
=hrs= strikes again.

#+begin_src emacs-lisp
(use-package engine-mode
  :config
  (engine-mode 1)
  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w"
    :docstring "Searchin' the wikis."))
#+end_src


* Magit
#+begin_src emacs-lisp
(use-package magit
  :config
  (hgf-c-def "d" 'magit-list-repositories))
#+end_src

** Repolist
I like Magit's repolist feature, but I prefer to build the repolist dynamically.

#+begin_src emacs-lisp
(defun hgf-list-subdirs (dir)
  "List all subdirs, not recursive, absolute names, DIR shouldn't have a / at the end."
  (let ((base dir)
	(result))
    (dolist (f (directory-files base) result)
      (let ((name (concat base "/" f)))
	(when (and (file-directory-p name)
		   (not (equal f ".."))
		   (not (equal f ".")))
	  (add-to-list 'result name))))
    result))

(defun hgf-contains-git-repo-p (dir)
  "Check if there's  a .git directory in DIR."
  (let ((dirs (directory-files dir)))
    (member ".git" dirs)))


(defun hgf-filter-git-repos (dirs)
  "Remove all directories without a .git subdirectory in DIRS."
  (let ((result))
    (dolist (dir dirs result)
      (when (hgf-contains-git-repo-p dir)
	(add-to-list 'result dir)))
    result))

(defun hgf-make-magit-repolist (dirs)
  "Make a list of the form (dir 0) for the magit-list-repositories function from DIRS."
  (let ((result))
    (dolist (dir dirs result)
      (add-to-list 'result `(,dir 0)))
    result))

(defun hgf-repolist-refresh ()
  "Hi."
  (setq magit-repository-directories
	(~> "~/dev"
	    (hgf-list-subdirs)
	    (hgf-filter-git-repos)
	    (hgf-make-magit-repolist))))

(advice-add 'magit-list-repositories :before #'hgf-repolist-refresh)

(setq magit-repolist-columns
      '(("Name" 12 magit-repolist-column-ident nil)
	("Branch" 10 magit-repolist-column-branch nil)
	("Dirty" 6 magit-repolist-column-dirty nil)
	("B<U" 3 magit-repolist-column-unpulled-from-upstream
	 ((:right-align t)
	  (:help-echo "Upstream changes not in branch")))
	("B>U" 3 magit-repolist-column-unpushed-to-upstream
	 ((:right-align t)
	  (:help-echo "Local changes not in upstream")))
	("Version" 30 magit-repolist-column-version nil)
	("Path" 99 magit-repolist-column-path nil)))
#+end_src

* Neotree

#+begin_src emacs-lisp
(use-package neotree
  :config
  (general-def "<f2>" 'neotree-toggle)
  (setq neo-theme 'arrow))
#+end_src

* Ivy

#+begin_src emacs-lisp
(use-package ivy
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t
	enable-recursive-minibuffers t
	ivy-initial-inputs-alist nil
	count-format "(%d/%d) "))

(use-package counsel
  :config
  (counsel-mode 1)
  (use-package flx)
  (use-package smex))

(use-package ivy-rich
  :config
  (ivy-rich-mode 1))

#+end_src

** =ivy-bibtex=

#+begin_src emacs-lisp
(use-package ivy-bibtex
  :config
  (setq ivy-re-builders-alist
	'((ivy-bibtex . ivy--regex-ignore-order)
	  (t . ivy--regex-plus)))
  (setq ivy-bibtex-default-action 'ivy-bibtex-insert-citation)
  (setq bibtex-completion-cite-default-command "autocite"
	bibtex-completion-cite-prompt-for-optional-arguments nil
	bibtex-completion-pdf-field "file")
  (setq bibtex-completion-pdf-open-function
	(lambda (fpath)
	  (call-process "zathura" nil 0 nil fpath)))
  (general-def "C-x [" 'ivy-bibtex))
#+end_src

* Projectile

#+begin_src emacs-lisp
(use-package projectile
  :config
  (projectile-mode +1)
  (hgf-leader-def
    "p" 'projectile-command-map
    "ff" 'projectile-find-file)
  (setq projectile-completion-system 'ivy)
  (setq projectile-project-search-path
	'("~/dev/uni"
	  "~/dev/fraunhofer"
	  "~/dev/ml"
	  "~/dev/yaks")))
#+end_src

Some additional utilities I mostly use with Projectile:
#+begin_src emacs-lisp
(use-package ripgrep)
#+end_src

* Yasnippet

#+begin_src emacs-lisp
(use-package yasnippet-snippets)
(use-package yasnippet
  :config
  (setq yas-indent-line 'fixed))
(yas-global-mode 1)
#+end_src


* Helpful

#+begin_src emacs-lisp
(use-package helpful
  :config
  (hgf-leader-def
    "h h" 'helpful-at-point)
  (general-def
    "C-h h" 'helpful-at-point
    "C-h k" 'helpful-key
    "C-h F" 'helpful-function
    "C-h C" 'helpful-command
    "C-c C-d" 'helpful-at-point)
  (setq counsel-describe-function-function 'helpful-callable
	counsel-describe-variable-function 'helpful-variable))
#+end_src


* Hydra
I'm not really using Hydra properly, except for the window management stuff that I seldom need to
use.

#+begin_src emacs-lisp
(use-package hydra
  :config
  (defhydra hydra-window ()
    "Window management"
    ("o" other-window "other")
    ("h" evil-window-left "left")
    ("j" evil-window-down "down")
    ("k" evil-window-up "up")
    ("l" evil-window-right "right")
    ("s" evil-window-split "split")
    ("v" evil-window-vsplit "vsplit")
    ("q" evil-quit "quit")
    ("f" find-file "file")
    ("b" ivy-switch-buffer "buffer")
    ("m" kill-this-buffer "murder")
    ("1" delete-other-windows "highlander")
    ("." nil "stop"))
  (defhydra hydra-files (:exit t)
    "Frequent files"
    ("e" (find-file (hgf-emacs-path "configuration.org")) "config")
    ("i" (find-file (hgf-journal-path "inbox.org")) "inbox")
    ("p" (counsel-find-file "~/cloud/journal/projects") "projects")
    ("f" (hydra-work/body) "fraunhofer")
    ("n" (find-file (hgf-journal-path "notes.org")) "notes")
    ("w" (find-file (hgf-journal-path "wiki.org")) "wiki")
    ("c" (hydra-configs/body) "configs")
    ("d" (find-file (hgf-journal-path "diet/diet.ledger")) "diet")
    ("D" (find-file (hgf-journal-path "diet/food.ledger")) "food")
    ("s" (hgf-generate-scratch-buffer) "scratch"))
  (defhydra hydra-configs (:exit t)
    "Configuration files"
    ("i" (find-file "~/.config/i3/config") "i3")
    ("g" (find-file "~/.config/git") "git")
    ("k" (find-file "~/.config/kitty/kitty.conf") "kitty")
    ("r" (find-file "~/.config/ranger/rc.conf") "ranger")
    ("R" (find-file "~/.config/rofi/config") "Rofi")
    ("e" (find-file (hgf-emacs-path "configuration.org")) "emacs")
    ("f" (find-file "~/.config/fish/config.fish") "fish"))
  (defhydra hydra-work (:exit t)
    "Configuration files"
    ("n" (find-file (hgf-journal-path "fraunhofer/notes.org")) "notes")
    ("t" (find-file (hgf-journal-path "fraunhofer/working_hours.ledger")) "working hours")
    ("p" (counsel-find-file (hgf-journal-path "fraunhofer/projects")) "projects"))
  (defhydra hydra-package (:exit t)
    "Package management"
    ("r" (package-refresh-contents) "refresh")
    ("i" (call-interactively #'package-install) "install")
    ("u" (package-utils-upgrade-all) "upgrade")
    ("d" (call-interactively #'package-delete) "delete"))
  (hgf-leader-def
    "P" 'hydra-package/body
    "f" 'hydra-files/body
    "w" 'hydra-window/body))
#+end_src

* Custom file

#+begin_src emacs-lisp
(setq custom-file (hgf-emacs-path "custom.el"))
(load custom-file 'noerror)
#+end_src

* Theme

#+begin_src emacs-lisp
(use-package autothemer)
#+end_src

I am partial to Nord.

#+begin_src emacs-lisp
(use-package nord-theme)
#+end_src

#+begin_src emacs-lisp
(use-package solarized-theme
  :config (setq solarized-scale-org-headlines nil
		solarized-use-variable-pitch nil
		solarized-height-plus-1 1
		solarized-height-plus-2 1
		solarized-height-plus-3 1
		solarized-height-plus-4 1
		solarized-high-contrast-mode-line t
		solarized-scale-org-headlines nil
		solarized-scale-outline-headlines nil
		solarized-use-less-bold t
		solarized-use-more-italic nil))
#+end_src

For setting transparency. I don't really use it, but it's there if I want to.
#+begin_src emacs-lisp
(defun transparency (value)
  "Sets the transparency of the frame window. 0=transparent/100=opaque."
  (interactive "nTransparency Value 0 - 100 opaque:")
  (set-frame-parameter (selected-frame) 'alpha value))
#+end_src

** Some goodies

#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src

** Set theme

Add some custom themes to the mix and make sure =rainbow-mode= is available.

#+begin_src emacs-lisp
(setq custom-theme-directory (hgf-emacs-path "themes/"))
;; (add-to-list 'custom-theme-load-path (hgf-emacs-path "themes/"))
(use-package rainbow-mode)
#+end_src

#+begin_src emacs-lisp
(defun hgf-disable-all-themes ()
  (dolist (theme custom-enabled-themes)
    (disable-theme theme)))

(defun hgf-load-theme (theme)
  "Disable all loaded themes and load THEME. Also sets certain face attributes I like to use."
  (interactive
   (list (intern (completing-read "Load custom theme: "
				  (mapcar 'symbol-name
					  (custom-available-themes))))))
  (unless (custom-theme-name-valid-p theme)
    (error "Invalid theme name `%s'" theme))
  (progn
    (hgf-disable-all-themes)
    (load-theme theme t)
    ))
(hgf-load-theme 'weatherwax)
#+end_src

* Triage

#+begin_src emacs-lisp
(defun hgf-switch-to-previous-buffer ()
  "Switch to previously open buffer.
      Repeated invocations toggle between the two most recently open buffers."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(general-def 'normal "DEL" 'hgf-switch-to-previous-buffer)

;; ** Delete file
(defun visiting-file-p ()
  "Check whether current buffer is visiting an existing file."
  (let ((filename (buffer-file-name)))
    (and filename (file-exists-p filename))))

(defun hgf-delete-this-file ()
  "Remove file connected to current buffer and kill buffer."
  (interactive)
  (let ((filename (buffer-file-name))
	(buffer (current-buffer))
	(name (buffer-name)))
    (if (not (visiting-file-p))
	(kill-buffer buffer)
      (when (yes-or-no-p "Delete this file? ")
	(delete-file filename)
	(kill-buffer buffer)
	(message "File %s successfully removed" filename)))))

;; ** Rename file
(defun hgf-rename-this-file ()
  "Rename current buffer and associated file."
  (interactive)
  (let ((name (buffer-name))
	(filename (buffer-file-name)))
    (if (not (visiting-file-p))
	(error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
	(if (get-buffer new-name)
	    (error "A buffer named '%s' already exists!" new-name)
	  (rename-file filename new-name 1)
	  (rename-buffer new-name)
	  (set-visited-file-name new-name)
	  (set-buffer-modified-p nil)
	  (message "File '%s' successfully renamed to '%s'"
		   name (file-name-nondirectory new-name)))))))

;; ** Get org title
(defun hgf-get-org-title ()
  "Get the raw string of the current buffer's #+TITLE property."
  (substring-no-properties
   (car (plist-get (org-export-get-environment) :title))))


;; ** Activate current task
(defun hgf-activate-current-task ()
  "Activate task under cursor."
  (interactive)
  (progn
    (message "hi")
    (let ((task (mapconcat 'identity (org-get-outline-path t) " â†’ ")))
      (progn
	(message task)
	(write-region (concat
		       (hgf-get-org-title)
		       " â†’ "
		       task) nil "~/.current_task")))))

(general-def "C-c h" 'hgf-activate-current-task)

(defun org-export-file-to-file (infile outfile backend)
  (write-region (org-export-string-as
		 (with-temp-buffer
		   (insert-file-contents infile)
		   (buffer-string))
		 backend)
		nil
		outfile))

(defun hgf-mktemp ()
  "Create a temporary scratch directory."
  (interactive)
  (counsel-find-file (s-trim (shell-command-to-string "mktemp -d"))))

#+end_src

* Prog mode
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'outshine-mode)
#+end_src




** Spell checking
#+begin_src emacs-lisp
#+end_src

* Text mode
I like auto-filling, 80 columns and spell-checking, thank you very much.
#+begin_src emacs-lisp
(use-package text-mode
  :ensure nil
  :config
  (setq-default fill-column 80)
  (add-hook 'text-mode-hook 'auto-fill-mode))
#+end_src

#+begin_src emacs-lisp
(use-package flyspell
  :ensure nil
  :config
  (setq ispell-program-name "aspell"
	ispell-extra-args '("--sug-mode=ultra"))
  (add-hook 'text-mode-hook 'flyspell-mode))
  
#+end_src
